<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ü§ñ Chatbot|Switch 1.0 ‚ö°</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* Global box-sizing for consistent layout calculations */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* Ensure html and body take full height to act as proper flex containers */
        html, body {
            height: 100%;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #1a1d23;
            margin: 0;
            padding: 0;
            /* Allow vertical scrolling on the body if content overflows */
            overflow-y: auto; 
            display: flex;
            flex-direction: column;
            color: #fff; /* Ensure text is visible */
        }

        h1 {
            color: #fff;
            text-align: center;
            font-size: 24px;
            margin-bottom: 10px;
            padding-top: 20px; /* Add some padding at the top */
            flex-shrink: 0; /* Prevent h1 from shrinking */
        }

        #chat-container {
            /* Fixed height to move input field up */
            height: 60vh; /* Adjust this value (e.g., 50vh, 70vh) to move it more or less */
            width: 90%; /* Adjusted for better mobile view */
            max-width: 800px; /* Max width for larger screens */
            margin: 0 auto; /* Center horizontally, removed bottom margin */
            padding: 20px;
            overflow-y: auto; /* This makes the chat content scrollable within its own container */
            background-color: #1a1d23;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border-radius: 10px; /* Unified border-radius */
            display: flex;
            flex-direction: column; /* Stack messages vertically */
        }

        #chat-container div {
            padding: 10px;
            border-bottom: 1px solid #2d3138;
            color: #fff;
            transform-style: preserve-3d;
            transform: translateZ(0);
            transition: transform 0.2s ease-in-out;
            border-radius: 8px; /* Rounded corners for messages */
            margin-bottom: 8px; /* Spacing between messages */
        }

        #chat-container div:last-child {
            border-bottom: none; /* No border for the last message */
        }

        #chat-container div:hover {
            transform: translateZ(5px); /* Slightly less aggressive hover for chat messages */
            background-color: #2d3138;
        }

        #input-area {
            padding: 20px;
            background-color: #1a1d23;
            border-top: 1px solid #2d3138;
            display: flex;
            justify-content: center; /* Center the input elements */
            align-items: center;
            gap: 15px; /* Space between input and button */
            width: 90%; /* Match chat container width */
            max-width: 800px; /* Match chat container max-width */
            margin: 0 auto; /* Center horizontally */
            border-radius: 0 0 10px 10px; /* Rounded bottom corners */
            flex-shrink: 0; /* Ensures it doesn't shrink and stays at its natural height */
        }

        #user-input {
            flex: 1; /* Allows input to grow */
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            background-color: #2d3138;
            color: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        #send-btn {
            padding: 15px 25px; /* Adjusted padding for a better button size */
            border: none;
            border-radius: 10px;
            background-color: #4CAF50;
            color: #fff;
            cursor: pointer;
            font-size: 18px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            transition: background-color 0.3s ease, transform 0.2s ease; /* Smooth transition */
        }

        #send-btn:hover {
            background-color: #3e8e41;
            transform: translateY(-2px); /* Lift effect on hover */
        }

        /* Styles for the main page scrollbar */
        body::-webkit-scrollbar {
            width: 10px;
            background-color: #1a1d23; /* Same as body background */
        }

        body::-webkit-scrollbar-thumb {
            background-color: #555; /* Darker gray for the thumb */
            border-radius: 10px;
        }

        /* Styles for the chat container's internal scrollbar */
        #chat-container::-webkit-scrollbar {
            width: 10px;
            background-color: #1a1d23;
        }

        #chat-container::-webkit-scrollbar-thumb {
            background-color: #2d3138;
            border-radius: 10px;
        }

        /* Responsive design */
        @media only screen and (max-width: 600px) {
            #chat-container, #input-area {
                width: 95%; /* Slightly wider on smaller screens */
                padding: 15px; /* Reduced padding */
            }
            #user-input {
                padding: 12px;
                font-size: 16px;
            }
            #send-btn {
                padding: 12px 20px;
                font-size: 16px;
            }
            #input-area {
                flex-direction: row; /* Keep elements in a row */
                gap: 10px;
            }
        }

        @media only screen and (max-width: 400px) {
            #chat-container, #input-area {
                width: 98%; /* Even wider on very small screens */
                padding: 10px;
            }
            #user-input {
                padding: 10px;
                font-size: 14px;
            }
            #send-btn {
                padding: 10px 15px;
                font-size: 14px;
            }
        }

        /* CSS for the enhanced typing animation */
        .typing-dots span {
            display: inline-block; /* Allows transform to work */
            opacity: 0;
            animation: bounce-dot 1.4s infinite; /* Changed animation name */
        }

        .typing-dots span:nth-child(1) { animation-delay: 0s; }
        .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes bounce-dot {
            0%, 100% {
                opacity: 0;
                transform: translateY(0); /* Start and end at original position */
            }
            25% {
                opacity: 1;
                transform: translateY(-5px); /* Move up */
            }
            50% {
                opacity: 1;
                transform: translateY(0); /* Come back down */
            }
            75% {
                opacity: 0; /* Fade out */
            }
        }
    </style>
</head>
<body>
    <h1>ü§ñ Chatbot|Switch 1.0 ‚ö°</h1>
    <div id="chat-container"></div>
    <div id="input-area"> <input type="text" id="user-input" placeholder="Type a command or /ai your question...">
        <button id="send-btn">Send</button>
    </div>

    <script>
        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');

        // --- Configuration for your API endpoints ---
        const PRIVATE_API_ENDPOINT = "https://api.giftedtech.web.id/api/ai/openai"; 
        const JOKE_API_ENDPOINT = "https://api.giftedtech.web.id/api/fun/jokes";
        const QUOTES_API_ENDPOINT = "https://api.giftedtech.web.id/api/fun/quotes";
        const ADVICE_API_ENDPOINT = "https://api.giftedtech.web.id/api/fun/advice";
        const LOVE_API_ENDPOINT = "https://api.giftedtech.web.id/api/fun/love";
        const FRIENDSHIP_API_ENDPOINT = "https://api.giftedtech.web.id/api/fun/friendship";
        const GRATITUDE_API_ENDPOINT = "https://api.giftedtech.web.id/api/fun/gratitude";
        const FANCY_API_ENDPOINT = "https://api.giftedtech.web.id/api/tools/fancy";
        const FANCYV2_API_ENDPOINT = "https://api.giftedtech.web.id/api/tools/fancyv2";

        const YOUR_API_KEY = "gifted"; // Your API key

        // Function to display bot messages
        function displayBotMessage(message, isHTML = false) {
            const botMessageDiv = document.createElement("div");
            if (isHTML) {
                botMessageDiv.innerHTML = `Bot: <br>${message}`;
            } else {
                botMessageDiv.textContent = `Bot: ${message}`;
            }
            chatContainer.appendChild(botMessageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        /**
         * Safely calculates a mathematical expression.
         * This function is a safer alternative to `eval()` but still executes code from a string.
         * For production applications requiring robust and secure math parsing,
         * consider using a dedicated math expression parsing library (e.g., math.js).
         * @param {string} expression The mathematical expression to calculate.
         * @returns {number} The result of the calculation.
         * @throws {Error} If the expression contains invalid characters or cannot be evaluated.
         */
        function safeCalculate(expression) {
            // Basic validation: allow only numbers, operators (+, -, *, /, ., parentheses), and spaces.
            // This prevents injection of arbitrary JavaScript code.
            if (!/^[0-9+\-*/.\s()]+$/.test(expression)) {
                throw new Error('Invalid characters in calculation. Only numbers and basic operators are allowed.');
            }

            try {
                // Using the Function constructor is safer than global eval() as it runs in its own scope.
                // It still executes code from a string, so strict input validation is crucial.
                return new Function('return ' + expression)();
            } catch (e) {
                // Catch any errors during evaluation (e.g., syntax errors)
                throw new Error('Could not evaluate expression. Please check syntax.');
            }
        }

        /**
         * Formats the raw AI response text into HTML with paragraphs, lists, and bolding.
         * @param {string} rawText The raw text response from the AI API.
         * @returns {string} The formatted HTML string.
         */
        function formatAiResponse(rawText) {
            // Normalize newlines and remove leading/trailing whitespace
            let processedText = rawText.trim().replace(/\r\n/g, '\n').replace(/\r/g, '\n');

            // Convert any **bold** markdown to <strong>bold</strong> HTML
            processedText = processedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

            const lines = processedText.split('\n');
            let htmlOutput = [];
            let inList = false;

            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine === '') {
                    // If an empty line is encountered and we were in a list, close the list
                    if (inList) {
                        htmlOutput.push('</ul>');
                        inList = false;
                    }
                    // Skip actual empty lines to avoid empty <p> tags
                    return;
                }

                if (trimmedLine.startsWith('- ')) {
                    if (!inList) {
                        htmlOutput.push('<ul>');
                        inList = true;
                    }
                    // Add list item, trimming the '- ' prefix
                    htmlOutput.push(`<li>${trimmedLine.substring(2).trim()}</li>`);
                } else {
                    // If we were in a list, close it before starting a new paragraph
                    if (inList) {
                        htmlOutput.push('</ul>');
                        inList = false;
                    }
                    // Wrap the line in a paragraph tag
                    htmlOutput.push(`<p>${trimmedLine}</p>`);
                }
            });

            // Close the list if it's still open at the very end of the text
            if (inList) {
                htmlOutput.push('</ul>');
            }

            return htmlOutput.join('');
        }


        /**
         * Generic function to fetch content from an API and handle common response structures.
         * @param {string} endpoint The API endpoint to call.
         * @param {string} loadingText Text to display while fetching.
         * @param {string} [queryParam='q'] The query parameter name for text-based APIs.
         * @param {string} [userQuery=''] The actual query text from the user.
         */
        async function fetchAPIContent(endpoint, loadingText, queryParam = '', userQuery = '') {
            const loadingMessageDiv = document.createElement("div");
            loadingMessageDiv.innerHTML = `Bot: ${loadingText}<span class="typing-dots"><span>.</span><span>.</span><span>.</span></span>`;
            chatContainer.appendChild(loadingMessageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;

            try {
                let url = `${endpoint}?apikey=${YOUR_API_KEY}`;
                if (queryParam && userQuery) {
                    url += `&${queryParam}=${encodeURIComponent(userQuery)}`;
                }
                
                const response = await fetch(url);

                if (!response.ok) {
                    let errorText = `HTTP Error: ${response.status} ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.message) {
                            errorText += ` - ${errorData.message}`;
                        }
                    } catch (jsonError) {
                        // If response is not JSON, use the status text
                    }
                    throw new Error(errorText);
                }

                const data = await response.json();
                console.log(`API response from ${endpoint}:`, data); // Log the full response for debugging

                let contentText;
                if (typeof data.result === 'string') {
                    contentText = data.result;
                } else if (typeof data.result === 'object' && data.result !== null) {
                    // Specific handling for JOKE_API_ENDPOINT, as it often returns setup/punchline
                    if (endpoint === JOKE_API_ENDPOINT) {
                        if (data.result.setup && data.result.punchline) {
                            contentText = `${data.result.setup} -- ${data.result.punchline}`;
                        } else if (data.result.joke) { // Fallback for a single 'joke' property within result (less common for this API)
                            contentText = data.result.joke;
                        } else {
                            contentText = `Joke API response 'result' is an object but lacks expected 'setup'/'punchline' or 'joke' properties. Raw object: ${JSON.stringify(data.result)}`;
                            console.warn("Joke API response 'result' property is an object without expected properties. Displaying raw object:", data.result);
                        }
                    }
                    // Generic object parsing for other APIs
                    else if (data.result.quote && data.result.author) { // For quotes API
                        contentText = `"${data.result.quote}" - ${data.result.author}`;
                    } else if (data.result.advice) { // For advice API
                        contentText = data.result.advice;
                    } else if (data.result.love) { // For love API
                        contentText = data.result.love;
                    } else if (data.result.friendship) { // For friendship API
                        contentText = data.result.friendship;
                    } else if (data.result.gratitude) { // For gratitude API
                        contentText = data.result.gratitude;
                    } else if (data.result.fancyText) { // For fancy text APIs (if reactivated)
                        contentText = data.result.fancyText;
                    }
                    else {
                        // Fallback: stringify the object if no specific content property is found within result
                        contentText = `API response 'result' is an object without a known property. Raw object: ${JSON.stringify(data.result)}`;
                        console.warn(`API response 'result' property for ${endpoint} is an object without a known property. Displaying raw object:`, data.result);
                    }
                } else if (data.fancyText) { // Check for 'fancyText' directly in the root 'data' object (for fancy APIs that might have this structure)
                    contentText = data.fancyText;
                }
                else {
                    // Fallback for unexpected data.result format (e.g., null, undefined, or non-object/non-string)
                    contentText = "Sorry, the API response was unexpected or empty.";
                    console.error(`API response for ${endpoint} has an unexpected format for 'result':`, data);
                }

                // If contentText is still undefined or an empty string after parsing,
                // and no specific error occurred, display a generic message.
                if (!contentText || contentText.trim() === "") {
                    contentText = "Sorry, I couldn't get content from the API or the content was empty.";
                }

                displayBotMessage(contentText); // Always display the processed botAnswer

            } catch (error) {
                console.error(`Error fetching from ${endpoint}:`, error);
                displayBotMessage(`Sorry, I couldn't fetch content right now. ${error.message ? `Error: ${error.message}` : 'Please try again later.'} üòî`);
            } finally {
                // Ensure loading message is always removed, regardless of success or error
                if (chatContainer.contains(loadingMessageDiv)) {
                    chatContainer.removeChild(loadingMessageDiv);
                }
            }
        }

        const commands = [
            { command: "help", response: `
                <p>‚ö° Commands Protocol Activated ‚ö°</p>
                <p>Dive into the future with these functionalities:</p>
                <ul>
                    <li><strong>/help</strong>: Access this data stream. üìö</li>
                    <li><strong>/about</strong>: Unveil bot specifications. ü§ñ</li>
                    <li><strong>/dev</strong>: Developer credits log. üíª</li>
                    <li><strong>/info</strong>: General system intelligence. üí°</li>
                    <li><strong>/socials</strong>: Connect on our networks. üîó</li>
                    <li><strong>/ai [query]</strong>: Initiate neural network query. üß†</li>
                    <li><strong>/joke</strong>: Retrieve a random humor byte. üòÇ</li>
                    <li><strong>/quotes</strong>: Download an inspirational data packet. üí°</li>
                    <li><strong>/advice</strong>: Access a wisdom algorithm. üß†</li>
                    <li><strong>/love</strong>: Generate a sentiment burst. ‚ù§Ô∏è</li>
                    <li><strong>/friend</strong>: Process a camaraderie encryption. ü§ù</li>
                    <li><strong>/gratitude</strong>: Synthesize an appreciation sequence. üôè</li>
                    <li><strong>/fancy [text]</strong>: Encode text with stylistic algorithms (v1). ‚ú® <em>(In Development)</em></li>
                    <li><strong>/fancy2 [text]</strong>: Encode text with stylistic algorithms (v2). üåü <em>(In Development)</em></li>
                    <li><strong>/quest1</strong>: Engage in coding exploration. üåê</li>
                    <li><strong>/quest2</strong>: Initiate advanced programming protocols. üöÄ</li>
                    <li><strong>/update</strong>: Check for system upgrades. ‚¨ÜÔ∏è</li>
                    <li><strong>/theme</strong>: Adjust interface schematics. üåà</li>
                    <li><strong>/reset</strong>: Reinitialize core processes. üîÑ</li>
                    <li><strong>/no.game</strong>: Current recreational modules inactive. üö´</li>
                    <li><strong>/ping</strong>: Network latency test. üì°</li>
                    <li><strong>/uptime</strong>: Display operational metrics. ‚è∞</li>
                    <li><strong>/api</strong>: Access API interface documentation. üìà</li>
                    <li><strong>/calculate [expression]</strong>: Compute complex algorithms. üßÆ</li>
                    <li><strong>/clear</strong>: Purge chat log. üóëÔ∏è</li>
                </ul>
                <p><em>Syntax: Input commands with a preceding slash '/'.</em></p>
            ` },
            { command: "about", response: "Switch 1.0 is a multipurpose online bot still in development with few inbuilt commands and integrated APIs. ü§ñ" },
            { command: "hi", response: "How are you doing today üòä" },
            { command: "what's up", response: "I'm good üëå" },
            { 
                command: "dev", 
                response: "Created By Musa Abiodun ü§ù Switch ‚Ñ¢ and other members of the class of H.A.P.E üéìüíª. We're passionate about innovation and building cool stuff! üöÄ" 
            },
            { command: "info", response: "Provides information and entertainment through various commands.üì∫" },
            { 
                command: "socials", 
                response: `
                    <p>‚ú® **Let's Connect!** üì≤</p>
                    <ul>
                        <li><strong>WhatsApp</strong>: <a href="https://wa.me/2349068649046" target="_blank">+2349068649046</a> üìû</li>
                        <li><strong>Telegram</strong>: <a href="https://t.me/lost_and_off" target="_blank">@lost_and_off</a> ‚úâÔ∏è</li>
                        <li><strong>Gmail</strong>: <a href="mailto:techxunlimited@gmail.com">techxunlimited@gmail.com</a> üìß</li>
                    </ul>
                    <p>_Feel free to reach out to our network coordinates!_ üåê</p>
                ` 
            },
            // /joke, /quotes, /advice, /love, /friend, /gratitude, /fancy, /fancy2 are now handled dynamically
            { command: "quest1", response: "Explore the world of coding and discover new things. üåê" },
            { command: "quest2", response: "Learn a new programming language and build something amazing. üíª" },
            { command: "update", response: "We're constantly updating and improving our chatbot. üöÄ" },
            { command: "theme", response: "Our theme is to provide a user-friendly and interactive experience. üåà" },
            { command: "reset", response: "Chatbot has been reset. üîÑ" },
            { command: "no.game", response: "No game available at the moment. üòî" },
            { command: "ping", response: "Pong! üèì" },
            { command: "uptime", response: "Uptime: 24/7 ‚è∞" },
            { command: "api", response: "Our API is used to provide various services and functionalities. üìà" },
            {
                command: "evaluate",
                response: () => {
                    const score = Math.floor(Math.random() * 100) + 1;
                    const encouragingWords = [
                        "Keep going!",
                        "You're on the right track!",
                        "Excellent work!",
                        "Don't give up!",
                        "You're making progress!",
                        "Great effort!",
                        "Good job!",
                        "Stay motivated!",
                        "You're doing well!",
                        "Keep pushing forward!",
                    ];
                    const encouragingWord =
                        encouragingWords[Math.floor(Math.random() * encouragingWords.length)];
                    return `<p>Evaluation Score: ${score}/100</p><p>${encouragingWord}</p>`;
                },
            },
        ];

        sendBtn.addEventListener("click", async () => {
            const userInputValue = userInput.value.trim();
            if (userInputValue === "") return;

            // Display user's message
            const userMessageDiv = document.createElement("div");
            userMessageDiv.textContent = `You: ${userInputValue}`;
            chatContainer.appendChild(userMessageDiv);

            // Clear input field immediately
            userInput.value = "";
            chatContainer.scrollTop = chatContainer.scrollHeight;

            const lowerCaseInput = userInputValue.toLowerCase();

            // Handle specific dynamic commands first
            if (lowerCaseInput === "/joke") {
                await fetchAPIContent(JOKE_API_ENDPOINT, "Fetching humor byte");
            } else if (lowerCaseInput === "/quotes") {
                await fetchAPIContent(QUOTES_API_ENDPOINT, "Downloading inspirational data");
            } else if (lowerCaseInput === "/advice") {
                await fetchAPIContent(ADVICE_API_ENDPOINT, "Accessing wisdom algorithm");
            } else if (lowerCaseInput === "/love") {
                await fetchAPIContent(LOVE_API_ENDPOINT, "Generating sentiment burst");
            } else if (lowerCaseInput === "/friend") {
                await fetchAPIContent(FRIENDSHIP_API_ENDPOINT, "Processing camaraderie encryption");
            } else if (lowerCaseInput === "/gratitude") {
                await fetchAPIContent(GRATITUDE_API_ENDPOINT, "Synthesizing appreciation sequence");
            } else if (lowerCaseInput.startsWith("/fancy ")) {
                // Modified /fancy command to show "In development"
                displayBotMessage("This command is currently in development. Please check back later! üõ†Ô∏è");
            } else if (lowerCaseInput.startsWith("/fancy2 ")) {
                // Modified /fancy2 command to show "In development"
                displayBotMessage("This command is currently in development. Please check back later! üõ†Ô∏è");
            } else if (lowerCaseInput.startsWith("/calculate")) {
                try {
                    const calculation = userInputValue.replace("/calculate ", "");
                    const result = safeCalculate(calculation); // Use safeCalculate
                    displayBotMessage(`Result: ${result} üßÆ`);
                } catch (error) {
                    displayBotMessage(`Error: ${error.message} ü§î`);
                }
            } else if (lowerCaseInput === "/clear") {
                chatContainer.innerHTML = "";
            } else if (lowerCaseInput.startsWith("/ai")) {
                // --- Handle /ai command for API call ---
                const aiQuery = userInputValue.substring(3).trim(); // Extract query after "/ai "
                if (aiQuery === "") {
                    displayBotMessage(`Please provide a question after /ai. For example: /ai What is JavaScript?`);
                    return;
                }

                const thinkingMessageDiv = document.createElement("div");
                // Added typing animation to the thinking message
                thinkingMessageDiv.innerHTML = `Bot: Thinking<span class="typing-dots"><span>.</span><span>.</span><span>.</span></span> ü§î`;
                chatContainer.appendChild(thinkingMessageDiv);
                chatContainer.scrollTop = chatContainer.scrollHeight;

                try {
                    const encodedQuery = encodeURIComponent(aiQuery);
                    // Using the PRIVATE_API_ENDPOINT for the /ai command
                    const url = `${PRIVATE_API_ENDPOINT}?apikey=${YOUR_API_KEY}&q=${encodedQuery}`;

                    const response = await fetch(url);

                    // Check if the HTTP response itself is not OK
                    if (!response.ok) {
                        let errorText = `HTTP Error: ${response.status} ${response.statusText}`;
                        try {
                            const errorData = await response.json();
                            if (errorData.message) {
                                errorText += ` - ${errorData.message}`;
                            }
                        } catch (jsonError) {
                            // If response is not JSON, use the status text
                        }
                        throw new Error(errorText);
                    }

                    const data = await response.json();
                    
                    let botAnswer;
                    if (data.result !== undefined && data.result !== null) {
                        let rawAiText = typeof data.result === 'object' ? JSON.stringify(data.result) : data.result;
                        botAnswer = formatAiResponse(rawAiText); // Format the AI response here
                    } else {
                        // If data.result is missing, stringify the entire data object for debugging
                        botAnswer = `I received an empty or unreadable response from the AI. Raw response: ${JSON.stringify(data)}`;
                        console.error("AI API response missing 'result' property or unexpected format:", data);
                    }
                    
                    // Pass true to displayBotMessage because botAnswer is now HTML
                    displayBotMessage(botAnswer, true); 

                } catch (error) {
                    console.error("Error fetching from private API:", error);
                    displayBotMessage(`Sorry, I couldn't get a response from the AI. ${error.message ? `Error: ${error.message}` : 'Please check the network or try again later.'} üòî`);
                } finally {
                    // Ensure thinking message is always removed, regardless of success or error
                    if (chatContainer.contains(thinkingMessageDiv)) {
                        chatContainer.removeChild(thinkingMessageDiv);
                    }
                }
            } else {
                // Handle other predefined commands
                const commandName = lowerCaseInput.substring(1); // Remove '/' for command lookup
                const command = commands.find((cmd) => cmd.command === commandName);
                if (command) {
                    displayBotMessage(
                        typeof command.response === "function" ? command.response() : command.response,
                        true // Pass true to indicate HTML content for these static commands
                    );
                } else if (
                    lowerCaseInput.includes("hello") ||
                    lowerCaseInput.includes("hi") ||
                    lowerCaseInput.includes("hey")
                ) {
                    displayBotMessage(`How are you doing today üòä`);
                } else {
                    // Default response for unrecognized commands
                    displayBotMessage(`Sorry, I don't understand that command. Type /help for available commands. üòï`);
                }
            }
            chatContainer.scrollTop = chatContainer.scrollHeight;
        });

        // Optional: Allow sending messages with Enter key
        userInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                sendBtn.click();
            }
        });
    </script>
</body>
</html>

